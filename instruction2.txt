00000000000000000000000000000000 // 0x00: NOP                     ; 移除 jal
00000000000000000000000000000000 // 0x04: NOP                     
00000000000000000000000000000000 // 0x08: NOP
00000000000000000000000000000000 // 0x0C: NOP

00100000000000010000000000000101 // 0x10: addi $1,$0,5            ; $1 = 5
00100000000000100000000000000111 // 0x14: addi $2,$0,7            ; $2 = 7
00000000001000100001100000100000 // 0x18: add  $3,$1,$2           ; $3 = $1 + $2
00000000001000100001100000100010 // 0x1C: sub  $3,$1,$2           ; $3 = $1 - $2
00000000001000100001100000100100 // 0x20: and  $3,$1,$2           ; AND
00000000001000100001100000100101 // 0x24: or   $3,$1,$2           ; OR
00000000001000100001100000101010 // 0x28: slt  $3,$1,$2           ; $3 = (5 < 7) = 1
00100000001001000000000000000101 // 0x2C: addi $4,$1,5            ; $4 = 5 + 5 = 10
00110100001001010000000000001010 // 0x30: ori  $5,$1,10           ; $5 = 5 | 10
00101000001001100000000000000101 // 0x34: slti $6,$1,5            ; $6 = (5 < 5)=0

00010000001000010000000000000010 // 0x38: beq $1,$1,+2            ; 成立 → 會跳（跳到 0x44）

00000000011001000011100000100000 // 0x3C: add  $7,$3,$4           ; 被跳過，不會執行
00000000011001000011100000100010 // 0x40: sub  $7,$3,$4           ; 被跳過，不會執行

00000000100001000010000000100000 // 0x44: add  $8,$4,$4           ; $8 = $4 + $4 = 20
10001100001010000000000000000000 // 0x48: lw   $8,0($1)           ; $8 = Mem[$1]
10101100001000010000000000000100 // 0x4C: sw   $1,4($1)           ; Mem[$1+4] = $1

00000000000000000000000000000000 // 0x50: NOP                     ; 移除 j
00000000000000000000000000000000 // 0x54: NOP
00000000000000000000000000000000 // 0x58: NOP
00000000000000000000000000000000 // 0x5C: NOP

00100001000010100000000000000001 // 0x60: addi $10,$8,1           ; 維持原本功能，不跳也能執行
10001100001010110000000000000100 // 0x64: lw $11, 4($1)           ; $11 = Mem[$1+4]
00000000000000000000000000000000 // 0x68: NOP                     ; 移除 jr
